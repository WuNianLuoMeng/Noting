# redis-多级数据库地实现

### * 复制(主从服务器是通过套接字来连接的)

+ **旧版复制功能的实现**

  复制功能分为两步：同步和命令传播

  + <font color="red">同步(SYNC)</font>

    + 从服务器向主服务器发送SYNC命令
    + 收到SYNC命令的主服务器执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令。
    + 当BGSAVE执行完毕之后，主服务器会将生成的RDB文件发送给从服务器。
    + 主服务器将缓冲区中所有的写命令发送个从服务器，从服务器执行这些命令更新至最新的状态。

  + <font color="red">命令传播</font>

    + 在同步操作完成之后，主从服务器达到了一致的状态。当是这种状态在主服务器去执行客户端写命令是会被打破，因此需要采用命令传播的方式来实现主服务器和从服务器达到一致的状态。
    + 命令传播就是当主服务器执行客户端的写操作时，此时主服务器会将该操作发送给从服务器，最终达到一致性的状态。

  + <font color="red">缺点：</font>

    由于同步阶段是通过主服务器创建RDB文件来实现的，那么当从服务器与主服务器之间的连接断开的时候，此时从服务器会重新与主服务器建立连接并且发送SYNC命令，这个时候就会造成一种情况就是从服务器中的有很多key-value都是不需要更新的，但是由于主服务器产生的RDB文件中包含了所有的key-value，所以从服务器在更新的时候，是以整个RDB文件去更新的。造成效率不是很高。

+ **新版复制功能的实现**

  为了解决旧版本的复制功能效率较低的问题，新版本使用PSYNC命令来代替SYNC来执行复制时的同步操作。

  + PSYNC有两中同步模式：完整重同步和部分重同步

    + 完整重同步与SYNC中的初次复制的情况是一样的。
    + 部分重同步使用从服务器与主服务器断线之后的情况，当从服务器断线后重新连接主服务器时，如果条件允许，主服务器可以将断线时的写命令发送给从服务器，从服务器只需要执行这些写命令即可。

  + <font color="red">部分重同步的实现：</font>

    + 部分重同步由三部分组成：主服务器的复制偏移量，主服务器的复制积压缓冲区，服务器的运行ID

    + <font color="red">复制偏移量：</font>这个参数时主从服务器来分别维护的。

      + 主服务器向从服务器发送N个字节的数据的时候，就将自身的复制偏移量的值加N
      + 从服务器成功接收到N个字节的数据之后，将自身的复制偏移量加N
      + 通过对比主从服务器的偏移量就可以判断出两者之间是否处于同步状态

    + <font color="red">复制积压缓冲区：</font>由主服务器维护的一个固定长度的FIFO队列，默认的大小为1MB。

      当主服务器进行命令传播的时候，它不仅会将写命令发送给从服务器，而且还会将这些命令复制到压缩缓冲区当中。并且复制挤压缓冲区中的每一项都会记录其相对应的复制偏移量。

      当从服务器再次与主服务器建立起连接的时候，那么此时从服务器就会将自己复制偏移量发送给主服务器，主服务器会根据这个偏移量来进行相应的操作。

      + 如果偏移量之后数据在队列当中，那么主服务器对从服务器就会采用部分重同步策略。
      + 如果复制偏移量之后的数据已经不再复制积压缓冲区中，那么此时主服务器就会对从服务器进行完整重同步策略。

    + <font color="red">服务器运行的ID：</font>该ID是当从服务器重新连接主服务器的时候，那么如果连接到的主服务器ID的值如果和这个ID一样的话，主服务器会继续执行部分重同步的策略，如果不一样的话，那么主服务器就会执行完整重同步的策略。

### *Sentinel(哨兵，哨岗)

​	由一个或者多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器下面的从服务器，并且在被监视的主服务器进入下线的状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，然后由新的主服务器代替已经下线的主服务器继续处理命令请求。

### *集群

集群通过分片来进行数据共享，并提供复制和故障转移的功能。

+ **节点**

  + 一个集群有多个节点组成，要创建一个集群的时候，要将各个独立的节点连接起来，构成一个包含多个节点的集群。

  + 连接各个节点的命令是:CLUSTER MEET < ip > < port >  

+ **槽指派**

  + 集群是通过分片的方式来保存数据库中的键值对的，集群的整个键值对被分成了16384个槽(slot),数据库中的每个键都属于这16384槽中的一个，集群中的每个节点可以处理0个或者做多16384个

  + 当数据库中的16384个槽都有节点在处理的时候，那么此时集群是出于上线功能的，相反的，如果有任何一个槽没有每节点处理的话，那么该集群就是下线的。

  + 底层结构

    ~~~ c++
    struct clusterNdoe{
        unsigned char slots[16384/8];//用来记录自身所负责的槽
        int numslots;               //负责槽的数目
    }
    //比如说槽i，那么就看slots[i]处是否为1，如果为1，就说明槽i被当前节点所负责
    ~~~

  + 传播节点的槽指派信息

    一个节点除了会将自己负责处理的槽记录在clusterNode中，而且它还会将自身的slots数组通过消息发送给集群中的其他节点，以来告知其他节点自己目前负责的槽。由于这种机制的存在，集群中的每个节点都会知道16384个槽都被哪些节点所负责。

  + 记录16384个槽的指派信息

    ~~~ c++
    struct clusterState{
        clusterNode *slots[16384];//数组中的每一项都会指定集群中的一个节点信息
        //slots[i]=null的话，那么说明槽i是没有被集群中的节点所负责	
    }
    ~~~

  + 计算键属于哪个槽的方法：CLUSTER KEYSLOT key

  + <font color="red">节点与单机数据库的一个区别是：节点只能使用编号为0的数据库，为单机数据库没有这个限制</font>

+ **集群中节点间的通信**

  MEET，PING，PONG，PUBLISH，FALL

  + MEET消息：当发送者接到客户端发送的CLUSTER MEET命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。
  + PING消息：集群中每个节点默认每个一秒钟就会从已知的节点列表中选取五个节点，然后对这五个节点发送PING消息以此来检测被选中的节点是否在线。
  + PONG消息：当接受者收到PING或者MEET信息的时候，为了向发送者确认接收方已经收到信息，接收方会向发送方发送一个PONG命令。
  + FALL消息：当一个主节点A判断主节点B已经进入FALL状态时，节点A会向集群广播一条关于节点B的FALL消息，所有收到这条消息的节点都会立即将节点B的FALL状态标记为已下线。
  + PUBLISH消息：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。