# 总结

### <font color="red">高并发错误的做法</font>

​	先删除缓存，然后在更新数据库，而后续的操作会把数据在装载到缓存当中。

#### 分析原因

假如说有两个并发操作，一个是更新操作，一个是查询操作，更新操作删除缓存之后，查询操作没有命中缓存，先把老的数据读取出来后放到缓存当中，但是更新操作却更新了数据库，于是缓存中的数据就是老的数据，导致了缓存中的数据是脏的。(一个更新，一个查询，查询操作的执行时间是要快于更新操作的，所以才会出现上述情况)。

## 正确的做法

### 做法一：Cache Aside Pattern(缓存旁侧模式)

- 过程：

  + **失效**：应用程序先从Cache中读取数据，然后假如没有得到，则从数据库中获取数

    据，成功后，放到缓存当中。

  + **命中**：应用程序从Cache中取数据，取到后返回。

  + **更新**：先把数据更新到数据库中，然后再让缓存中的数据失效。

    这里为什么要让缓存失效而不是直接更新缓存中的信息呢？

    理由：如果A,B两个线程同时做数据更新，A先更新了数据库，B后更新数据库，则此时数据库里存的是B的数据。而更新缓存的时候，是B先更新了缓存，而A后更新了缓存，则缓存里是A的数据。这样缓存和数据库的数据也不一致。

  + 这种方式理论上可能会出现并发的安全性问题：一个读操作，一个写操作，当读操作没有在缓存中命中数据的时候，那么此时会到数据库中读取数据，那么当读线程读取完数据之后，写操作会来更新数据，那么此时读操作将刚才的读取的数据写入到缓存中，此时就会出现脏读的情况。但是该情况出现的可能性不是很大，因为这个条件需要发生在都缓存失效并且还并发着一个写操作，而且实际上写操作回避读操作要慢，如果读操作在写操作之前读取数据，当写操作完成之后，会清空缓存，如果在写操作之后读取数据就更不会出现脏读的情况。

### 做法二：Read/Write Through Pattern(读/写模式)

​	在上面的Cache Aside套路中，应用代码需要维护两个数据存储，一个是缓存（Cache），一个是数据库（Repository）。所以，应用程序比较啰嗦。而Read/Write Through套路是把更新数据库（Repository）的操作由缓存自己代理了，所以，对于应用层来说，就简单很多了。**可以理解为，应用认为后端就是一个单一的存储，而存储自己维护自己的Cache。**

+ **Read Through**(只读缓存)

  当应用程序向缓存中发送请求时，如果该缓存中没有所要请求的内容时，那么此时

  Coherence缓存框架就会自动委派给CacheStore(是一个特定于应用程序的适配器，用于将缓存连接到基础的数据源)并且要求它将用户所请求的数据加载出来，并将其返回到Coherence，然后Coherence将其放入缓存中以供将使用。

+ **Write Through**

  当应用程序要更新数据的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后再由Coherence通过CacheStore更新数据库（这是一个同步操作）

+ ##### Write Behind

  该模式是与Write Through作比较的，该模式的套路就是在更新数据的时候，只更新缓存，而不更新数据库，更新数据库的操作及那个通过一步批量完成。缺点就是可能回去丢失数据，对于那些更新的内容，该模式中存在一个后写队列来去维护。







### ++++++++++++++++++++++++++++++++++++++++++++++++++

# 缓存穿透，缓存雪崩

### 缓存穿透

​	就是用户所要查询的数据缓存和数据库中都是没有的，那么每次用户的请求都会到数据库中查询，增加数据库的压力。

#### 解决方案

+ 采用布隆过滤器或者压缩filter提前拦截，不合法的请求不让其请求带数据库层。
+ 可以将这个空的对象缓存到数据库中并设置一个过期的时间，下次再请求的时候就不会访问数据库了。

### 缓存雪崩

#### 两种情况

+ Redis挂掉了，请求全部走数据库。
+ 对缓存设置得过期时间，导致某段时间内缓存失效请求全部走数据库。

### 解决办法

+ 对于第一种情况
  + 事发前，实现Redis的高可用(比如说主从复制，集群，哨兵等模式)。
  + 事发中，加锁排队. 限流-- 限流算法。
  + 事发后，Redis持久化，重启恢复数据。
+ 对于第二种情况
  + 在缓存的时候给过期时间加上一个随机值，这样就会大幅度减少缓存在同一时间过期。





















