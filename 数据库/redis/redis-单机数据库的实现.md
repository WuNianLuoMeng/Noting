# redis-单机数据库的实现

### * 数据库

+ Redis服务器默认会创建16个数据库。

+ 切换数据库命令：select number(数据库编号)

+ 添加key-value：SET命令（更新key的value值也是该条命令）

+ 删除key-value：DEL(KEY)命令

+ 取值：GET

+ 设置键的生存时间：EXPIRE key time(s)

  ​				   PEXPIRE key time(ms)

  ​				   客户端：EXPIREAT key time(s)

  ​						   PEXPIREAT key time(ms)

+ **过期键删除策略**

  + 定时删除：通过设置定时器，定时删除策略可以保证过期间会尽可能快的删除，并释放掉内存。
    + 缺点：对内存来说是友好的，但是对CPU来说是不友好的，删除过期键会占用CPU一部分时间。

  + 惰性删除：程序只会在取出键的时候才会对键进行检查，看其是否过期。
    + 缺点：对CPU是友好的，但是对于内存来说是不友好的，有可能过期的键不能被及时的删除。
  + 定期删除：前两种方式的一种折中，每隔一段时间进行删除键操作，并且限制删除操作时间和频率来减少对CPU的占用。
    + 难点：就是如何控制好删除键操作的时间和频率，如果时间过长会退化为定时删除，如果删除次数太少会退化为惰性删除。

+ **Redis过期键的删除**

  + 惰性策略
  + 定期策略

### *RDB持久化(保存的是key-value)

+ RDB文件的创建与载入
  + 通过SAVA或者GBSAVE命令来完成RGB文件的创建。
  + 两者的区别
    + SAVA：会阻塞Redis服务器进程，知道RDB文件创建完毕为止，在服务器阻塞期间，服务器不能处理任何命令请求。
    + BGSAVA：会发出一个子进程，然后有子进程负责RDB文件的创建，父线程继续处理命令请求。
  + RDB的载入是在服务器启动的时候自动执行的。

### *AOF持久化(保存的是语句信息)

+ **AOF持久化实现**

  + 命令追加

    当AOF持久化功能处于打开的状态时，服务器在执行完一个写命令之后，会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾。

  + 文件写入与同步

    该功能是由appendfsync的属性值来实现的

    + always：将aof_buf缓冲区的所有内容写入并同步到AOF文件中
    + everysec：将aof_buf缓冲区中的所有内容写入到AOF文件中，如果上次同步AOF文件的时间距离现在超过了1s，那么会接着执行同步功能。
    + no：将aof_buf中的内容写入到AOF文件中，但是此时不会执行同步功能，何时同步是由操作系统来决定的。
    + 三者的比较分析：
      + always：效率最慢，但是安全性最高。
      + everysec：效率要比always高点，安全性比always低一点。
      + no：效率最高，没有同步，但是安全性确是最低的。

+ **AOF文件的载入过程**

  + 创建一个不带网络连接的伪客户端。
  + 从AOF文件中分析并读取一条写命令。
  + 使用伪客户端执行被读出的命令。
  + 重复第二步和第三步，知道文件被读取完。

+ **AOF文件的重写**
  + 原因：随着操作数越来越多，AOF文件的容量会越来越大，此时不加以控制的话，会对Redis服务器造成影响。
  + 命令行：退出redis-cli,然后执行./redis-cli bgrewriteaof
  + 后台重写AOF文件
    + 命令行：BGREWRITEAOF，创建了一个子进程来重写AOF文件，服务器进程仍然可以处理刻划断发来的命令。
    + 过程：为了保证子进程在重写AOF文件的时候，客户端有可能会再次发来请求，导致AOF文件与当前服务器数据库状态不一致的情况，Redis服务器设置了一个AOF重写缓冲区，这个缓冲区创建子进程之后来实使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。
    + 当子进程完成AOF重写工作之后，它会向父进程发送一个信号，父线程在接收到信号之后，会执行一下动作：
      + 将AOF重写缓冲区中的所有内容写入到新的AOF文件中。
      + 将新的AOF文件进行改名，原子地覆盖现有的AOF文件，完成新旧两个AOF文件的替换。



